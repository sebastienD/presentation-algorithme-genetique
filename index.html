<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Les algorithmes genetiques</title>

		<meta name="description" content="Introduction aux algorithmes génétiques">
		<meta name="author" content="Sebastien Descamps">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Les algorithmes genetiques</h1>
					<p>
						<small>by <a href="http://www.zenika.com">Sebastien n°2</a></small>
					</p>
				</section>

				<section>
					<section>
						<h2>Wikipedia</h2>
						<p><blockquote>
							&ldquo;Les algorithmes génétiques appartiennent à la famille des <a href="#" class="navigate-down">algorithmes évolutionnistes</a>. Leur but est d'obtenir une solution approchée à un problème d'optimisation, lorsqu'il n'existe pas de méthode exacte (ou que la solution est inconnue) pour le résoudre en un temps raisonnable. Les algorithmes génétiques utilisent la notion de sélection naturelle et l'appliquent à une population de solutions potentielles au problème donné. La solution est approchée par « bonds » successifs.&rdquo;
						</blockquote></p>
					</section>
					<section>
						<p><blockquote>
						&ldquo;Les algorithmes évolutionnistes sont une famille d'algorithmes s'inspirant de la théorie de l'évolution pour résoudre des problèmes divers. Ils font ainsi évoluer un ensemble de solutions à un problème donné, dans l'optique de trouver les meilleurs résultats. Ce sont des algorithmes stochastiques, car ils utilisent itérativement des processus aléatoires.&rdquo;
						</blockquote></p>
					</section>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
					<section>
						<h2>Origines</h2>
						<ul>
							<li>1860 : Charles Darwin publie son livre intitulé "L'origine des espèces au moyen de la sélection naturelle ou la lutte pour l'existence dans la nature" et expose sa théorie de l'évolution des espèces.
							
						</ul>
					</section>
					<section>
						<ul>
							<li>1960 : John Holland ainsi que ses collègues et élèves de l'Université du Michigan débutent des travaux de recherche sur les algorithmes génétiques.</li>
							<li>1966 : Le Docteur Lawrence J. Fogel présente sa thèse sur la programmation évolutionnaire. 
							<li>1973 : Ingo Rechenberg travaille sur des méthodes d'optimisation connu sous le nom de "Stratégie d'évolution".
							<li>1975 : John Holland introduit le premier modèle formel des algorithmes génétiques avec la prise en compte de l'opérateur d'enjambement en complément des mutations. Ce modèle servira de base aux recherches ultèrieures.</li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h2>Principe</h2>
						<p>Générer une population de n individus initiaux. La population d'individus doit être non homogène et servira de base pour les générations futures. Par analogie avec la génétique, chaque individu est codé par un chromosome (comportant donc plusieurs gènes).</p>
					</section>
					<section>
						<p>On évalue les différentes solutions proposées, afin de les "classer" en fonction de leur pertinence. Pour cela, on utilise une fonction d’évaluation qui permettra ensuite de faire la sélection.</p>
						<p>La population sélectionnée est divisée en couples, formés aléatoirement. L’algorithme sélectionne un ou plusieurs gène(s) sur chacun des deux individus.</p>
						<p>On applique ensuite un algorithme qui aura pour role de modifier un gêne au hasard. La probabilité doit être assez faible.</p>
					</section>
					<section>
						<p>Il ne reste plus qu'à effectuer ces opérations un maximum de fois de façon à augmenter la justesse du résultat. On peut choisir d’arrêter l’algorithme lorsqu’un individu obtient une note jugée suffisamment satisfaisante, ou après un certain nombre de générations.</p>
					</section>
					<section>
						<img height="710px" width ="600px" src="img/diagrammeAG.jpg" >
					</section>
				</section>

				<section>
					<h2>Le codage ou modelisation</h2>
					<ol>
						<li>codage binaire</li>
						<li>codage à caractères multiples</li>
						<li>codage sous forme d'arbre</li>
					</ol>
				</section>

				<section>
					<h2>La population initiale</h2>
					<p>
						La taille de la population initiales est laissée à l'appéciation du programmeur.
						Il n'est souvent pas nécessaire d'utiliser des populations démesurées. Une taille de 100 ou 150 individus s'avèrera souvent amplement suffisante, tant pour la qualité des solutions trouvées que pour le temps d'exécution de notre algorithme.
					</p>
				</section>

				<section>
					<h2>La fonction d'évaluation ou fonction fitness</h2>
					<p>
						Pour calculer le coût d'un point de l'espace de recherche, on utilise une fonction d'évaluation. L'évaluation d'un individu ne dépendant pas de celle des autres individus, le résultat fournit par la fonction d'évaluation va permettre de sélectionner ou de refuser un individu pour ne garder que les individus ayant le meilleur coût en fonction de la population courante : c'est le rôle de la fonction fitness. Cette méthode permet de s'assurer que les individus performants seront conservés, alors que les individus peu adaptés seront progressivement éliminés de la population.
					</p>
				</section>

				<section>
					<section>
						<h2>La selection</h2>
						<ol>
							<li>la selection par roulette</li>
							<li>la selection par rang</li>
							<li>la selection steady-state</li>
							<li>la selection par tournoi</li>
							<li>l'élitisme</li>
						</ol>
					</section>
					<section>
						<h2>La selection par roulette</h2>
						<img width="543px" height="485px" src="img/roue.png">
					</section>
					<section>
						<h2>La selection par rang</h2>
						<table>
							<thead>
								<th>Chromosomes</th>
								<th>1</th>
								<th>2</th>
								<th>3</th>
								<th>4</th>
								<th>5</th>
								<th>6</th>
								<th>Total</th>
							</thead>
							<tbody>
								<tr>
									<td>Evaluation</td>
									<td>89</td>
									<td>5</td>
									<td>1</td>
									<td>4</td>
									<td>3</td>
									<td>2</td>
									<td>100</td>
								</tr>
								<tr>
									<td>Rang</td>
									<td>6</td>
									<td>5</td>
									<td>1</td>
									<td>4</td>
									<td>3</td>
									<td>2</td>
									<td>21</td>
								</tr>
								<tr>
									<td>Probabilité</td>
									<td>29%</td>
									<td>24%</td>
									<td>5%</td>
									<td>19%</td>
									<td>14%</td>
									<td>9%</td>
									<td>100%</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h2>La sélection steady-state</h2>
						<p>
							A chaque génération sont sélectionnés quelques chromosomes parmi ceux qui ont le meilleur résultat pour créer des chromosomes fils. Ensuite les chromosomes les plus mauvais sont retirés et remplacés par les nouveaux. Le reste de la population survie à la nouvelle génération.
						</p>
					</section>
					<section>
						<h2>La sélection par tournoi</h2>
						<p>
							Le principe de la sélection par tournoi augmente les chances pour les individus de piètre qualité de participer à l'amélioration de la population. Un tournoi consiste en une rencontre entre plusieurs individus pris au hasard dans la population. Le vainqueur du tournoi est l'individu de meilleure qualité. Vous pouvez choisir de ne conserver que le vainqueur comme vous pouvez choisir de conserver les 2 meilleurs individus ou les 3 meilleurs. A vous de voir, selon que vous souhaitez créer beaucoup de tournois, ou bien créer des tournois avec beaucoup de participants ou bien mettre en avant ceux qui gagnent les tournois haut la main. Vous pouvez faire participer un même individu à plusieurs tournois.
						</p>
					</section>
					<section>
						<h2>L'élitisme</h2>
						<p>
							Elle consiste à copier un ou plusieurs des meilleurs chromosomes dans la nouvelle génération. Ensuite, on génère le reste de la population selon l'algorithme de reproduction usuel. Cette méthode améliore considérablement les algorithmes génétiques, car elle permet de ne pas perdre les meilleurs solutions.
						</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Le croisement ou hybridation ou enjambement ou crossover</h2>
						<p>
							A partir de deux individus, on obtient deux nouveaux individus (enfants) qui héritent de certaines caractéristiques de leurs parents. L'hybridation sélectionnne des gènes parmis deux individus appelés parents. A partir de ces gènes sont générés les enfants
						</p>
						<p>
							L'hybridation est mis en place pour que les nouveaux chromosomes gardent la meilleur partie des chromosomes anciens. Ceci dans le but d'obtenir, peut-être, de meilleurs chromosomes. 
						</p>
						<p>
							Il n'est pas nécessaire et surtout pas recommandé de croiser tous les individus d'une population, car rien ne nous dit si le résultat d'un croisement sera meilleur ou moins bon que les individus parents.
						</p>
					</section>
					<section>
						<img src="img/genes.png">
					</section>
				</section>

				<section>
					<h2>La mutation</h2>
					<p>
						pour ne pas tomber dans un algorithme aléatoire (entre 0,1% et 1% en général)
					</p>
				</section>

				<section>
					<h2>Insertion des nouveaux individus dans la population</h2>
					Une fois que nous avons créé de nouveaux individus que ce soit par croisements ou par mutations, il nous faut sélectionner ceux qui vont continuer à participer à l'amélioration de notre population. Une fois encore, libre au programmeur de choisir ceux qu'il souhaite conserver. Il est possible de refaire une étape d'évaluation des individus nouvellement créés. De même qu'il est possible de conserver tous les nouveaux individus en plus de notre population.

					Une méthode relativement efficace consiste à insérer les nouveaux individus dans la population, à trier cette population selon l'évaluation de ses membres, et à ne conserver que les N meilleurs individus.

					 
				</section>

				<section>
					<section>
						<h2>Itérations</h2>
						Effectuer ces opérations un maximum de fois de façon à augmenter la justesse du résultat. On peut choisir d’arrêter l’algorithme lorsqu’un individu obtient une note jugée suffisamment satisfaisante, ou après un certain nombre de générations 
					</section>
					<section>
						<img src="img/schema_gen.gif" >
					</section>
				</section>

				<section>
					<h2>Conditions d'utilisation</h2>
					<p>
						Comme cela a été dit plus haut, les algorithmes génétiques peuvent être une bonne solution pour résoudre un problème. Néanmoins, leur utilisation doit être conditionnée par certaines caractéristiques du problème.

Les caractéristiques à prendre en compte sont les suivantes :

Le temps de calcul de la fonction d'évalutation (fitness en anglais) doit être raisonnablement court. En effet, celle-ci sera évaluée de nombreuses fois.
Nombre de solutions important : les performances des algorithmes génétiques par rapport aux algorithmes classiques sont plus marquées lorsque les espaces de recherches sont importants. En effet, pour un espace dont la taille est faible, il peut être plus sûr de parcourir cet espace de manière exhaustive afin d'obtenir la solution optimale en un temps qui restera somme toute correct. Au contraire, utiliser un algorithme génétique engendrera le risque d'obtenir une solution non optimale (voir la section limites) en un temps qui restera sensiblement identique.
Pas d'algorithme déterministe adapté et raisonnable.
Lorsque l'on préfère avoir une solution relativement bonne rapidement plutôt qu'avoir la solution optimale en une durée indéfinie. C'est ainsi que les algorithmes génétiques sont utilisés pour la programmation de machines qui doivent être très réactives aux conditions environnantes.
					</p>
				</section>

				<section>
					<h2>Applications</h2>
					<ol>
						<li>les algorithmes génétiques ont été mis à contribution en économie et en finance.</li>
						<li>certaines industries utilisent les algorithmes génétiques pour la programmation des robots d'assemblage, dans l'industrie automobile par exemple, ou dans le domaine de l'aérodynamique dans un souci d'optimisation structurelle.</li>
						<li>mise en place de logiciels d’optimisation comme Evolver pour Microsoft Excel par exemple.</li>
						<li>La NASA a adopté ces algorithmes dans le cadre de l’exploration de Mars pour les déplacements du robot Pathfinder.</li>
					</ol>
				</section>

				<section>
					<section>
						<h2>Limites</h2>
						<ol>
							<li>Si les algorithmes génétiques convergent vers une solution, quand cette solution est inconnue, rien n’assure que le résultat soit la solution optimale ; d’où une nécessité d’effectuer un grand nombre de simulations. Au début, les solutions vont s’améliorer rapidement (recherche globale), mais par la suite, elles peuvent rester longtemps proches de la solution optimale sans jamais l’atteindre (recherche locale). De plus, le temps de calcul est relativement long : il faut donc l’utiliser pour les cas où le nombre de solutions est vraiment important, afin de "rentabiliser" (pour les problèmes avec peu de solutions, la méthode exhaustive est plus rapide, et donne la solution optimale).</li>
							<li> la fonction de fitness, et certains paramètres comme le taux de mutation ou la taille de la population sont difficiles à mettre en place.</li>
						</ol>
					</section>
					<section>
						<p>

Le temps de calcul : par rapport à d'autres métaheuristiques, ils nécessitent de nombreux calculs, en particulier au niveau de la fonction d'évaluation.
Ils sont le plus souvent difficiles à mettre en œuvre : des paramètres comme la taille de la population ou le taux de mutation sont parfois difficiles à déterminer. Or le succès de l'évolution en dépend et plusieurs essais sont donc nécessaires, ce qui limite encore l'efficacité de l'algorithme. En outre, choisir une bonne fonction d'évaluation est aussi critique. Celle-ci doit prendre en compte les bons paramètres du problème. Elle doit donc être choisie avec soin.
Il faut aussi noter l'impossibilité d'être assuré, même après un nombre important de générations, que la solution trouvée soit la meilleure. On peut seulement être sûr que l'on s'est approché de la solution optimale (pour les paramètres et la fonction d'évaluation choisie), sans la certitude de l'avoir atteinte.
Un autre problème important est celui des optima locaux. En effet, lorsqu'une population évolue, il se peut que certains individus qui à un instant occupent une place importante au sein de cette population deviennent majoritaires. À ce moment, il se peut que la population converge vers cet individu et s'écarte ainsi d'individus plus intéressants mais trop éloignés de l'individu vers lequel on converge. Pour vaincre ce problème, il existe différentes méthodes comme l'ajout de quelques individus générés aléatoirement à chaque génération, des méthodes de sélection différentes de la méthode classique…
						</p>
					</section>
					<section>
						<img src="img/cochon.jpg">
					</section>
				</section>

				<section>
					<section>
						<h1>"La vie trouve toujours son chemin."</h1>
						<small>Dr Ian Malcolm , Jurassic Park</small>
					</section>
					<section>
						<ul>
							<li>http://pro.cleamax.fr/info-bioinspiree/?p=gene</li>
							<li>http://khayyam.developpez.com/articles/algo/genetic/</li>
							<li>http://sis.univ-tln.fr/~tollari/TER/AlgoGen1/node5.html</li>
							<li>http://fr.wikipedia.org/wiki/Algorithme_g%C3%A9n%C3%A9tique</li>
						</ul>
					</section>
				</section>

				<section>
					<h2>Genetic car</h2>
					<a href="http://boxcar2d.com/about.html" target="_blank">http://boxcar2d.com/about.html</a>

				</section>

				<section>
					<h2>Définition d'une voiture</h2>
					<h4>un chassi défini par</h4>
					<ul>
						<li>[float] une densité comprise entre 30 et 300</li>
						<li>[float,float] 8 vecteurs (paires de coordonnées) ou chaque valeur absolue non nulle d'une coordonnée est comprise entre 0.1 et 1.1</li>
					</ul>
					<pre>
(X,0) (X,Y) (0,Y) (-X,Y) (-X,0) (-X,-Y) (0,-Y) (X, -Y)
					</pre>

					<h4>2 roues définies par</h4>
					<ul>
						<li>[float] un rayon compris entre 0.2 et 0.5</li>
						<li>[float] une densité comprise entre 40 et 100</li>
						<li>[int] un sommet compris entre 0 et 7</li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
